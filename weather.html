<!doctype html>
<title>weather</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<style>
  body {
    margin: 0;
    overflow: hidden;
  }
  card {
    border: 1px solid black;
    border-radius: 8px;
    display: inline-block;
    min-width: 48px;
    margin-top: 8px;
    padding: 4px 0 0 8px;
    font-size: 20px;
  }
  card::before {
    position: absolute;
    display: block;
    transform: translate(-4px, -12px);
    background: white;
    font-size: small;
    padding: 0 4px;
  }
  #date::before {
    content: "Date";
  }
  #date {
    margin-left: 4px;
  }
  #temp::before {
    content: "Temp";
  }
  #uv::before {
    content: "UV";
    color: #ff00ff;
  }
  #aqi::before {
    content: "AQI";
  }
  #covid::before {
    content: "d\000394covid";
  }
  #covid {
    min-width: 64px;
  }
  #uv {
    border-color: #ff00ff;
    color: #ff00ff;
    min-width: 24px;
  }
  #aqi {
    min-width: 32px;
  }
  #canvas {
    display: block;
  }
</style>
<div id=loading></div>
<card id=date></card>
<card id=temp></card>
<card id=uv></card>
<card id=aqi></card>
<card id=covid></card>
<canvas id=canvas></canvas>

<script>

// TODO no magic numbers
// TODO location.hash = lat,lon,metric
// TODO rain bars, rainCard
// TODO merge axes
// TODO radar link
// TODO metric/imperial button

const MS_PER_HOUR = 1000 * 60 * 60;
const MS_PER_DAY = MS_PER_HOUR * 24;
const AIR_SENSOR_MILES = 5;
const AIR_SENSOR_DEGREES = parseInt((AIR_SENSOR_MILES * 360 / 24901) * 10000) / 10000;
const FONT_PX = 40;
const LINE_HEIGHT_PX = FONT_PX * 1.25;

const W = {
  drawClouds() {
    let prevClouds = W.hours[W.now.getHours()].clouds;
    W._ctx.fillStyle = W._clouds(prevClouds);
    W._ctx.fillRect(0, 110, 100, 25);
    for (let h = W.now.getHours() + 1; h < 24; ++h) {
      const clouds = W.hours[h].clouds;
      if ('number' !== typeof clouds) continue;
      const y = 85 + (50 * (h - W.now.getHours()));
      const grd = W._ctx.createLinearGradient(0, y, 0, y + 50);
      grd.addColorStop(0, W._clouds(prevClouds));
      grd.addColorStop(1, W._clouds(clouds));
      W._ctx.fillStyle = grd;
      W._ctx.fillRect(0, y, 100, 50);
      prevClouds = clouds;
    }
    W._ctx.fillStyle = W._clouds(prevClouds);
    W._ctx.fillRect(0, 85 + (50 * (24 - W.now.getHours())), 100, 25);

    for (let d = 0; d < 5; ++d) {
      const clouds = W.days[d].clouds;
      if ('number' !== typeof clouds) continue;
      const y = 160 + (50 * (d + 24 - W.now.getHours()));
      W._ctx.fillStyle = W._clouds(clouds);
      W._ctx.fillRect(0, y, 100, 50);
    }
  },

  _day(date) {
    return 'UMTWRFS'[date.getDay()] + date.getDate();
  },
  
  lerp(v0, v1, t) {
    return (v0 * (1 - t)) + (v1 * t);
  },

  _convertTemp(k, metric = true) {
    const c = k - 273.15;
    return metric ? c : (c * (9 / 5) + 32);
  },

  _mean(s) {
    let sum = 0;
    for (const e of s) sum += e;
    return sum / s.length;
  },

  async fetchCachedJson(options) {
    const now = new Date();
    const url = options.url;
    const expiryMs = options.expiryMs;
    delete options.url;
    delete options.expiryMs;

    const cached = JSON.parse(localStorage.getItem(url) || 'null');
    if (cached && (now < cached.expires)) {
      console.log('cachehit', url, cached.response);
      return cached.response;
    }

    console.log('fetching', url);
    const response = await (await fetch(url, options)).json();
    console.log('received', url, response);
    const expires = now.getTime() + expiryMs;
    localStorage.setItem(url, JSON.stringify({expires, response}));
    return response;
  },

  sweepStorage() {
    const now = new Date();
    for (let i = 0; i < localStorage.length; ++i) {
      const k = localStorage.key(i);
      try {
        const cached = JSON.parse(localStorage.getItem(k));
        if (now > cached.expires) {
          localStorage.removeItem(k);
        }
      } catch(e) {
      }
    }
  },
  
  async reload() {
    return await W.load({latitude: W.lat, longitude: W.lon});
  },

  async load(coords) {
    if (W.loading) {
      return;
    }
    W.loading = true;
    try {
      W.lat = Math.round(coords.latitude * 10) / 10;
      W.lon = Math.round(coords.longitude * 10) / 10;
      W.now = new Date();
      console.log('loading', W.lat, W.lon, W.now);
      W.metric = localStorage.getItem('metric') !== null;
      W.hours = {};
      for (let h = W.now.getHours(); h < 24; ++h) {
        W.hours[h] = {};
      }
      W.days = {};
      const date = new Date(W.now.toDateString()).getTime();
      for (let d = 0; d < 5; ++d) {
        W.days[d] = {date: new Date(date + ((d + 1) * MS_PER_DAY))};
      }
      W.minima = {rain: 0, uv: 0};
      W.maxima = {rain: 0, uv: 0};
      W.pm25 = null;
      W.aqi = null;
      W.weatherLoaded = W.loadWeather();
      await Promise.all([W.weatherLoaded, W.loadUv(), W.loadAir(), W.loadCovid()]);
      W.sweepStorage();
      W.draw();
    } catch (e) {
      document.body.innerText = e.stack;
    }
    W.loading = false;
  },
  
  setupCanvas() {
    W._canvas = document.getElementById('canvas');
    const h = (130 + (50 * (6 + 24 - W.now.getHours()))) / (devicePixelRatio || 1);
    W._canvas.width = innerWidth * (devicePixelRatio || 1);
    W._canvas.height = h * (devicePixelRatio || 1);
    W._canvas.style.width = innerWidth + 'px';
    W._canvas.style.height = h + 'px';
    W._ctx = W._canvas.getContext('2d');
    W._ctx.clearRect(0, 0, W._canvas.width, W._canvas.height);
  },
  
  async loadCovid() {
    const date = new Date(new Date(W.now.toDateString()) - (3 * MS_PER_DAY)).toISOString();
    const data = await W.fetchCachedJson({
      url: `https://api.covid19api.com/live/country/united-states/status/confirmed/date/${date}`,
      expiryMs: MS_PER_DAY,
    });
    // TODO find Province by Lat/Lon?
    W._covid = data.filter(d => d.Province === 'California');
  },
  
  drawCovid() {
    const card = document.getElementById('covid');
    const delta = W._covid[W._covid.length - 1].Active - W._covid[W._covid.length - 2].Active;
    card.innerText = ((delta >= 0) ? '+' : '') + delta;
    card.onclick = () => {
      open(`https://openweathermap.org/weathermap?basemap=map&cities=true&layer=precipitation&lat=${W.lat}&lon=${W.lon}&zoom=5`);
    };
  },

  async loadWeather() {
    // https://openweathermap.org/api/one-call-api
    // https://home.openweathermap.org/api_keys
    const w = await W.fetchCachedJson({
      url: `https://api.openweathermap.org/data/2.5/onecall?lat=${W.lat}&lon=${W.lon}&appid=4f7a34d2b44e009df9246dbca025d0b5`,
      expiryMs: MS_PER_HOUR,
    });
    for (const datum of w.hourly) {
      const date = new Date(datum.dt * 1000);
      if (date.getDate() != W.now.getDate()) continue;
      const target = W.hours[date.getHours()];
      if (!target) continue;
      Object.assign(target, {
        temp: datum.temp,
        feels: datum.feels_like,
        clouds: datum.clouds,
        humidity: datum.humidity,
        rain: (datum.rain || {})['1h'] || 0,
      });
      for (const k of Object.keys(target)) {
        W.minima[k] = Math.min(W.minima[k] || 1000000, target[k]);
        W.maxima[k] = Math.max(W.maxima[k] || -1000000, target[k]);
      }
    }
    
    for (const datum of w.daily) {
      const date = new Date(datum.dt * 1000);
      const target = W.days[parseInt((date - W.now) / MS_PER_DAY) - 1];
      if (!target) continue;
      Object.assign(target, {
        temp: [datum.temp.min, datum.temp.max],
        clouds: datum.clouds,
        humidity: datum.humidity,
        rain: datum.rain || 0,
      });
      for (const k of ['clouds', 'humidity', 'rain']) {
        W.minima[k] = Math.min(W.minima[k] || 1000000, target[k]);
        W.maxima[k] = Math.max(W.maxima[k] || -1000000, target[k]);
      }
      W.minima.temp = Math.min(W.minima.temp, target.temp[0]);
      W.maxima.temp = Math.max(W.maxima.temp, target.temp[1]);
    }

    for (const k of ['temp', 'feels']) {
      W.maxima[k] = W._convertTemp(W.maxima[k], W.metric);
      W.minima[k] = W._convertTemp(W.minima[k], W.metric);
      for (const h of Object.values(W.hours)) {
        h[k] = W._convertTemp(h[k], W.metric);
      }
    }
    for (const d of Object.values(W.days)) {
      d.temp = [W._convertTemp(d.temp[0], W.metric), W._convertTemp(d.temp[1], W.metric)];
    }
  },

  async loadUv() {
    // https://www.openuv.io/
    const date = new Date(W.now.toDateString()).getTime();
    const uv = await Promise.all([0, 1, 2, 3, 4, 5, 6].map(d => W.fetchCachedJson({
      url: `https://api.openuv.io/api/v1/forecast?lat=${W.lat}&lng=${W.lon}&dt=${new Date(date + (d * MS_PER_DAY)).toISOString()}`,
      headers: {'x-access-token': '0e881fcec14d82a8eb011877e61bfc21'},
      expiryMs: MS_PER_DAY,
    })));
    await W.weatherLoaded;
    for (const dayDatum of uv) {
      for (const hourDatum of dayDatum.result) {
        const date = new Date(hourDatum.uv_time);
        if (date.getDate() === W.now.getDate()) {
          const target = W.hours[date.getHours()];
          console.log('addUv', date.getDate(), date.getHours(), hourDatum.uv, target);
          if (!target) continue;
          target.uv = hourDatum.uv * (1 - 0.7 * (target.cloud || 0) / 100);
        } else if (date > W.now) {
          const targetIndex = parseInt((new Date(date.toDateString()) - new Date(W.now.toDateString())) / MS_PER_DAY) - 1;
          console.log('addUv', date.getDate(), date.getHours(), hourDatum.uv, targetIndex, W.days[targetIndex]);
          const target = W.days[targetIndex];
          if (!target) continue;
          target.uv = Math.max(hourDatum.uv, target.uv || 0);
        }
      }
    }
  },

  async loadAir() {
    const minlat = W.lat - AIR_SENSOR_DEGREES;
    const maxlat = W.lat + AIR_SENSOR_DEGREES;
    const minlon = W.lon - AIR_SENSOR_DEGREES;
    const maxlon = W.lon + AIR_SENSOR_DEGREES;
    let a;
    try {
      a = await W.fetchCachedJson({
        url: `https://www.purpleair.com/data.json?opt=1/mAQI/a10/cC0&fetch=true&nwlat=${maxlat}&selat=${minlat}&nwlng=${minlon}&selng=${maxlon}&fields=pm_1`,
        expiryMs: MS_PER_HOUR / 2,
      });
    } catch(e) {
      console.error(`Error fetching air quality:\n${e.stack}\n`);
      return;
    }
    // Mean particulate mass < 2.5um in ug/m^3.
    W.pm25 = W._mean(a.data.map(row => {
      const datum = {};
      for (let i = 0; i < a.fields.length; ++i) {
        datum[a.fields[i]] = row[i];
      }
      return datum;
    }).filter(datum => datum.Lat !== null && datum.Lon !== null && datum.age < 30).map(s => s.pm_1 || 0));
    W.aqi = W.pm25 * 50 / 30;
  },
  
  draw() {
    document.getElementById('date').innerText = W._day(W.now);
    W.setupCanvas();
    W.drawRain();
    W.drawAxes();
    W.drawClouds();
    W.drawHours();
    W.drawDays();
    W.drawNow();
    W.drawAqi();
    W.drawCovid();
  },
  
  drawRain() {
    for (let h = W.now.getHours(); h < 24; ++h) {
      const datum = W.hours[h];
      const y = 150 + (50 * (h - W.now.getHours()));
      console.log('drawRain', h, datum.rain, y);
    }
    for (let d = 0; d < 5; ++d) {
      const datum = W.days[d];
      const y = 200 + (50 * (d + 24 - W.now.getHours()));
      console.log('drawRain', d, datum.rain, y);
    }
  },
  
  drawAqi() {
    const card = document.getElementById('aqi');
    if (W.aqi === null) {
      card.style.display = 'none';
    } else {
      card.style.color = card.style.borderColor = ['#00cc00', '#66cc00', '#ffff00', '#ff9900', '#ff0000', '#a52a2a'][parseInt(W.aqi / 50)];
      card.innerText = parseInt(W.aqi);
      card.onclick = () => {
        open(`https://www.purpleair.com/map?opt=1/mAQI/a10/cC0#11/${W.lat}/${W.lon}`);
      };
    }
  },
  
  drawNow() {
    W._ctx.strokeStyle = '#ff0000';
    W._ctx.beginPath();
    const timeY = 150 - 15 + (50 * W.now.getMinutes() / 60);
    W._ctx.moveTo(100, timeY);
    W._ctx.lineTo(W._canvas.width - 70, timeY);
    W._ctx.stroke();
  },
  
  _clouds(clouds) {
    return `hsl(216, ${100 - clouds}%, 80%)`;
  },
  
  drawAxes() {
    W._ctx.font = '40px Helvetica';
    W._ctx.lineWidth = 1;
    W._ctx.textAlign = 'center';
    W._ctx.strokeStyle = '#888888';

    let dTempTick = W.metric ? 2 : 5;
    let minTempTick = dTempTick + (dTempTick * parseInt(W.minima.temp / dTempTick));
    let maxTempTick = dTempTick * parseInt(W.maxima.temp / dTempTick);
    for (let tick = minTempTick; tick <= maxTempTick; tick += dTempTick) {
      const x = 100 + ((W._canvas.width - 100 - 70) * (tick - W.minima.temp) / (W.maxima.temp - W.minima.temp));
      W._ctx.fillText(tick, x, 50);
      W._ctx.beginPath();
      W._ctx.moveTo(x, 135);
      W._ctx.lineTo(x, 135 + (50 * (6 + 24 - W.now.getHours())));
      W._ctx.stroke();
    }
    
    W._ctx.textAlign = 'right';
    W._ctx.fillText(String.fromCharCode(0xb0) + (W.metric ? 'C' : 'F'), W._canvas.width - 10, 50);

    W._ctx.strokeStyle = W._ctx.fillStyle = '#ff00ff';
    W._ctx.fillText('UV', W._canvas.width - 10, 100);
    
    W._ctx.textAlign = 'center';
    for (let uvi = 1; uvi < 12; uvi++) {
      const x = 70 + ((W._canvas.width - 100 - 70) * uvi / 12);
      W._ctx.fillText(uvi, x, 100);
    }
    
    W._ctx.strokeStyle = '#000000';
    W._ctx.fillStyle = '#000000';
  },

  drawHours() {
    W._ctx.textAlign = 'right';
    W._ctx.strokeStyle = '#888888';
    W._ctx.fillStyle = 'black';

    for (let h = W.now.getHours(); h < 24; ++h) {
      const datum = W.hours[h];
      const y = 150 + (50 * (h - W.now.getHours()));
      W._ctx.fillText((h % 12) == 0 ? 12 : (h % 12), 90, y);
      W._ctx.beginPath();
      W._ctx.moveTo(100, y - 15);
      W._ctx.lineTo(W._canvas.width - 70, y - 15);
      W._ctx.stroke();
    }

    W._ctx.strokeStyle = '#000000';
    W._ctx.beginPath();
    let y = 135;
    let x = 100 + ((W._canvas.width - 100 - 70) * (W.hours[W.now.getHours()].temp - W.minima.temp) / (W.maxima.temp - W.minima.temp));
    W._ctx.moveTo(x, y);
    for (let h = W.now.getHours() + 1; h < 24; ++h) {
      x = 100 + ((W._canvas.width - 100 - 70) * (W.hours[h].temp - W.minima.temp) / (W.maxima.temp - W.minima.temp));
      y += 50;
      W._ctx.lineTo(x, y);
    }
    W._ctx.stroke();

    W._ctx.strokeStyle = '#ff00ff';
    W._ctx.beginPath();
    y = 135;
    x = 100 + ((W._canvas.width - 100 - 70) * W.hours[W.now.getHours()].uv / 12);
    W._ctx.moveTo(x, y);
    for (let h = W.now.getHours() + 1; h < 24; ++h) {
      x = 100 + ((W._canvas.width - 100 - 70) * W.hours[h].uv / 12);
      y += 50;
      W._ctx.lineTo(x, y);
    }
    W._ctx.stroke();
    
    const tempCard = document.getElementById('temp');
    const uvCard = document.getElementById('uv');
    const prevHour = W.hours[W.now.getHours()];
    const nextHour = W.hours[W.now.getHours() + 1];
    if (nextHour) {
      const minuteFrac = W.now.getMinutes() / 60
      uvCard.innerText = parseInt(Math.round(W.lerp(
        prevHour.uv || 0,
        nextHour.uv || 0,
        minuteFrac
      )));
      const lerpTemp = W.lerp(prevHour.temp, nextHour.temp, minuteFrac);
      const metricPow = W.metric ? 10 : 1;
      tempCard.innerText = (W.metric
        ? (Math.round(lerpTemp * 10) / 10)
        : parseInt(Math.round(lerpTemp))) + String.fromCharCode(0xb0) + (W.metric ? 'C' : 'F');
    } else {
      uvCard.innerText = 0;
      tempCard.innerText = prevHour.temp;
    }
  },

  drawDays() {
    W._ctx.strokeStyle = '#888888';
    for (let d = 0; d < 5; ++d) {
      const datum = W.days[d];
      const y = 200 + (50 * (d + 24 - W.now.getHours()));
      W._ctx.fillText(W._day(datum.date), 90, y);
      W._ctx.beginPath();
      W._ctx.moveTo(100, y - 15);
      W._ctx.lineTo(W._canvas.width - 70, y - 15);
      W._ctx.stroke();
    }

    W._ctx.fillStyle = '#aaaaaa';
    for (let d = 0; d < 5; ++d) {
      const datum = W.days[d];
      const y = 200 + (50 * (d + 24 - W.now.getHours())) - 30;
      const x = 100 + ((W._canvas.width - 100 - 70) * (datum.temp[0] - W.minima.temp) / (W.maxima.temp - W.minima.temp));
      const w = 100 + ((W._canvas.width - 100 - 70) * (datum.temp[1] - W.minima.temp) / (W.maxima.temp - W.minima.temp)) - x;
      W._ctx.fillRect(x, y, w, 30);
    }

    W._ctx.strokeStyle = '#ff00ff';
    W._ctx.lineWidth = 2;
    W._ctx.beginPath();
    for (let d = 0; d < 5; ++d) {
      const datum = W.days[d];
      const y = 200 + (50 * (d + 24 - W.now.getHours())) - 30;
      const x = 100 + ((W._canvas.width - 100 - 70) * datum.uv / 12) - 15;
      W._ctx.moveTo(x,y+15);
      W._ctx.lineTo(x+30,y+15);
      W._ctx.moveTo(x+15,y);
      W._ctx.lineTo(x+15,y+30);
      W._ctx.moveTo(x+5,y+5);
      W._ctx.lineTo(x+25,y+25);
      W._ctx.moveTo(x+25,y+5);
      W._ctx.lineTo(x+5,y+25);
    }
    W._ctx.stroke();
  },
};

addEventListener('load', async() => {
  let coords = null;
  try {
    coords = JSON.parse(localStorage.getItem('geolocation') || 'null');
  } catch (e) {
    console.log('coords failed to parse');
  }
  if (coords) {
    W.load(coords);
  }
  console.log('geolocating');
  navigator.geolocation.getCurrentPosition(async (pos) => {
    if (!coords
        || (Math.abs(coords.latitude - pos.coords.latitude) > 0.1)
        || (Math.abs(coords.longitude - pos.coords.longitude) > 0.1)) {
      W.load(pos.coords);
    } else {
      console.log('already loaded coords', coords);
    }
    localStorage.setItem('geolocation', JSON.stringify({
      latitude: pos.coords.latitude,
      longitude: pos.coords.longitude,
    }));
  }, e => {
    document.body.innerText = e.message;
  }, {
  });
  
  window.setTimeout(function() {
    W.reload();
  }, 1000 * 60 * 5);

  document.addEventListener('visibilitychange', function() {
    if (!document.hidden) {
      W.reload();
    }
  });
});
</script>
