<canvas id=canvas>
<script>
const MS_PER_HOUR = 1000 * 60 * 60;
function convertTemp(k, metric = true) {
  const c = k - 273.15;
  return metric ? c : (c * (9 / 5) + 32);
}
const SCALAR_NAMES = ['temp', 'feels_like', 'wind_speed', 'humidity', 'pressure'];
navigator.geolocation.getCurrentPosition(async (pos) => {
  const lat = parseInt(pos.coords.latitude * 10) / 10;
  const lon = parseInt(pos.coords.longitude * 10) / 10;
  const cacheKey = `${lat} ${lon}`;
  const cached = JSON.parse(localStorage.getItem(cacheKey) || 'null');
  const metric = localStorage.getItem('metric') !== null;
  const now = new Date();
  let result = {date: now, hours: [], days: [], minima: {}, maxima: {}};
  if (cached && (MS_PER_HOUR > (cached && (now - new Date(cached.date))))) {
    result = cached.result;
  } else {
    const owm = await (await fetch(`https://api.openweathermap.org/data/2.5/onecall?lat=${lat}&lon=${lon}&appid=4f7a34d2b44e009df9246dbca025d0b5`)).json();
    const uvforecast = (await (await fetch(`https://api.openuv.io/api/v1/forecast?lat=${lat}&lng=${lon}`, {
      headers: {'x-access-token': '0e881fcec14d82a8eb011877e61bfc21'},
    })).json()).result.map(h => ({t: new Date(h.uv_time), uv: h.uv}));
    for (let h = now.getHours(); h < 24; ++h) {
      result.hours[h] = {};
    }
    for (let d = 0; d < 5; ++d) {
      result.days[d] = {};
    }
    // TODO {date: iso8601, maxima: {uv, temp, feels, wind, humidity, pressure}, minima: {uv, temp, feels, wind, humidity, pressure}, hours: {n: {uv: i, temp: k, feels: k, wind: ?, humidity: ?, pressure: ?}}, days: {n: {uv: max, temp: [min, max], feels: [min, max], wind: [min, max], humidity: [min, max], pressure: [min, max]}}}
    localStorage.setItem(cacheKey, JSON.stringify(result));
  }
  console.log(result);
  const ctx = canvas.getContext('2d');

  for (const k of ['temp', 'feels_like']) {
    result.maxima[k] = convertTemp(result.maxima[k], metric);
    result.minima[k] = convertTemp(result.minima[k], metric);
    for (const h of result.hourly) {
      h[k] = convertTemp(h[k], metric);
    }
    for (const d of result.daily) {
      for (const x of Object.keys(d[k])) {
        d[k][x] = convertTemp(d[k][x], metric);
      }
    }
  }

  result.maxima = {};
  result.minima = {};
  result.hours = {};
  for (const h of result.hourly) {
    h.date = new Date(h.dt * 1000);
    result.hours[h.date.getHours()] = h;
    for (const k of SCALAR_NAMES) {
      result.maxima[k] = Math.max(result.maxima[k] || 0, h[k]);
      result.minima[k] = Math.min(result.minima[k] || 1000000, h[k]);
    }
    if (h.date.getHours() > 20) break;
  }
  for (const datum of result.uvforecast) {
    // TODO adjust for clouds
    if (!result.hours[datum.t.getHours()]) continue;
    result.hours[datum.t.getHours()].uv = datum.uv;
    if (datum.t.getHours() > 20) break;
  }
  
  // TODO draw axes
  
  for (let h = now.getHours(); h < 20; ++h) {
    const datum = result.hours[h];
    console.log({h, datum});
    ctx.fillText(h, 0, 20 * (h - now.getHours()));
    // TODO draw tick
  }
  for (let d = 0; d < 5; ++d) {
    const datum = result.days[d];
    console.log({d, datum});
    ctx.fillText(d, 0, 20 * (d + 20 - now.getHours()));
    // TODO draw tick
  }
});
</script>
