<!doctype html>
<title>weather</title>
<style>
  body {
    margin: 0;
  }
  canvas {
    width: 100%;
    height: 100%;
  }
</style>
<canvas id=canvas>

<script>
const MS_PER_HOUR = 1000 * 60 * 60;
const MS_PER_DAY = MS_PER_HOUR * 24;
const AIR_SENSOR_MILES = 5;
const AIR_SENSOR_DEGREES = parseInt((AIR_SENSOR_MILES * 360 / 24901) * 10000) / 10000;

function convertTemp(k, metric = true) {
  const c = k - 273.15;
  return metric ? c : (c * (9 / 5) + 32);
}

function mean(s) {
  let sum = 0;
  for (const e of s) sum += e;
  return sum / s.length;
}
  
async function fetchJson(url, options) {
  const response = await fetch(url, options);
  return await response.json();
}
  
async function fetchCachedJson(options) {
  const now = new Date();
  const url = options.url;
  const expiryMs = options.expiryMs;
  delete options.url;
  delete options.expiryMs;

  const cached = JSON.parse(localStorage.getItem(url) || 'null');
  if (cached && (now < cached.expires)) {
    console.log('cachehit', url, cached.response);
    return cached.response;
  }

  console.log('fetching', url);
  const response = await fetchJson(url, options);
  console.log('received', url, response.length);
  const expires = now.getTime() + expiryMs;
  localStorage.setItem(url, JSON.stringify({expires, response}));
  return response;
}

function sweepStorage() {
  const now = new Date();
  for (let i = 0; i < localStorage.length; ++i) {
    const k = localStorage.key(i);
    const cached = JSON.parse(localStorage.getItem(k));
    if (now > cached.expires) {
      localStorage.removeItem(k);
    }
  }
}
  
class Forecast {
  constructor(lat, lon) {
    this.lat = parseInt(lat * 10) / 10;
    this.lon = parseInt(lon * 10) / 10;
    this.now = new Date();
    this.metric = localStorage.getItem('metric') !== null;
    this.hours = {};
    for (let h = this.now.getHours(); h < 24; ++h) {
      this.hours[h] = {};
    }
    this.days = {};
    const date = new Date(this.now.toDateString()).getTime();
    for (let d = 0; d < 5; ++d) {
      this.days[d] = {date: new Date(date + ((d + 1) * MS_PER_DAY))};
    }
    this.minima = {};
    this.maxima = {};
    this.pm25 = 0;
    this.weatherLoaded = this.fetchWeather();
    this.uvLoaded = this.fetchUv();
    this.airLoaded = this.fetchAir();
    this.loaded = Promise.all([this.weatherLoaded, this.uvLoaded, this.airLoaded]);
  }
  
  async fetchWeather() {
    this.addWeather(await fetchCachedJson({
      url: `https://api.openweathermap.org/data/2.5/onecall?lat=${this.lat}&lon=${this.lon}&appid=4f7a34d2b44e009df9246dbca025d0b5`,
      expiryMs: MS_PER_HOUR,
    }));
  }
  
  addWeather(w) {
    for (const datum of w.hourly) {
      const date = new Date(datum.dt * 1000);
      if (date.getDate() != this.now.getDate()) continue;
      const target = this.hours[date.getHours()];
      if (!target) continue;
      Object.assign(target, {
        temp: datum.temp,
        feels: datum.feels_like,
        clouds: datum.clouds,
        humidity: datum.humidity,
      });
      for (const k of Object.keys(target)) {
        this.minima[k] = Math.min(this.minima[k] || 1000000, target[k]);
        this.maxima[k] = Math.max(this.maxima[k] || -1000000, target[k]);
      }
    }
    
    for (const datum of w.daily) {
      const date = new Date(datum.dt * 1000);
      const target = this.days[parseInt((date - this.now) / MS_PER_DAY)];
      if (!target) continue;
      Object.assign(target, {
        date,
        temp: [datum.temp.min, datum.temp.max],
        clouds: datum.clouds,
        humidity: datum.humidity,
      });
      for (const k of ['clouds', 'humidity']) {
        this.minima[k] = Math.min(this.minima[k] || 1000000, target[k]);
        this.maxima[k] = Math.max(this.maxima[k] || -1000000, target[k]);
      }
      this.minima.temp = Math.min(this.minima.temp, target.temp[0]);
      this.maxima.temp = Math.max(this.maxima.temp, target.temp[1]);
    }

    for (const k of ['temp', 'feels']) {
      this.maxima[k] = convertTemp(this.maxima[k], this.metric);
      this.minima[k] = convertTemp(this.minima[k], this.metric);
      for (const h of Object.values(this.hours)) {
        h[k] = convertTemp(h[k], this.metric);
      }
    }
    for (const d of Object.values(this.days)) {
      d.temp = [convertTemp(d.temp[0], this.metric), convertTemp(d.temp[1], this.metric)];
    }
  }

  async fetchUv() {
    const date = new Date(this.now.toDateString()).getTime();
    const uvDays = await Promise.all([0, 1, 2, 3, 4, 5].map(d => fetchCachedJson({
      url: `https://api.openuv.io/api/v1/forecast?lat=${this.lat}&lng=${this.lon}&dt=${new Date(date + (d * MS_PER_DAY)).toISOString()}`,
      headers: {'x-access-token': '0e881fcec14d82a8eb011877e61bfc21'},
      expiryMs: MS_PER_DAY,
    })));
    await this.weatherLoaded;
    this.addUv(uvDays);
  }

  addUv(uv) {
    for (const datum of uv[0].result) {
      const date = new Date(datum.uv_time);
      if (date.getDate() != this.now.getDate()) continue;
      const target = this.hours[date.getHours()];
      if (!target) continue;
      target.uv = datum.uv * (1 - (0.7 * ((target.clouds || 0) / 100)));
    }
    for (const data of uv.slice(1).map(r => r.result)) {
      for (const datum of data) {
        const date = new Date(datum.uv_time);
        const target = this.days[parseInt((date - this.now) / MS_PER_DAY)];
        if (!target) continue;
        target.uv = Math.max(target.uv || 0, datum.uv);
      }
    }
  }

  async fetchAir() {
    const minlat = this.lat - AIR_SENSOR_DEGREES;
    const maxlat = this.lat + AIR_SENSOR_DEGREES;
    const minlon = this.lon - AIR_SENSOR_DEGREES;
    const maxlon = this.lon + AIR_SENSOR_DEGREES;
    this.addAir(await fetchCachedJson({
      url: `https://www.purpleair.com/data.json?fields=pm_1&opt=1/mAQI/a10/cC0&nwlat=${maxlat}&selat=${minlat}&nwlng=${minlon}&selng=${maxlon}`,
      expiryMs: MS_PER_HOUR / 2,
    }));
  }

  addAir(a) {
    // Mean particulate mass < 2.5um in ug/m^3.
    this.pm25 = mean(a.data.map(row => {
      const datum = {};
      for (let i = 0; i < a.fields.length; ++i) {
        datum[a.fields[i]] = row[i];
      }
      return datum;
    }).filter(datum => datum.Lat !== null && datum.Lon !== null && datum.age < 30).map(s => s.pm_1 || 0));
  }
  
  draw(ctx) {
    this.drawAxes(ctx);
    this.drawHours(ctx);
    this.drawDays(ctx);
    // TODO display purple air button when pm25 > 10
  }

  drawAxes(ctx) {
    // TODO
  }

  drawHours(ctx) {
    for (let h = now.getHours(); h < 24; ++h) {
      const datum = this.hours[h];
      ctx.fillText(h % 12, 0, 20 * (h - now.getHours()));
      ctx.moveTo(20, 20 * (h - now.getHours()));
      ctx.lineTo(20, canvas.width - 20);
    }
  }

  drawDays(ctx) {
    for (let d = 0; d < 5; ++d) {
      const datum = this.days[d];
      ctx.fillText(datum.date.getDate(), 0, 20 * (d + 24 - now.getHours()));
      ctx.moveTo(20, 20 * (d + 24 - now.getHours()));
      ctx.lineTo(20, canvas.width - 20);
    }
  }
}

console.log('geolocating');
navigator.geolocation.getCurrentPosition(async (pos) => {
  console.log(pos.coords);
  const f = new Forecast(pos.coords.latitude, pos.coords.longitude);
  sweepStorage();
  canvas.width = innerWidth * (devicePixelRatio || 1);
  canvas.height = innerHeight * (devicePixelRatio || 1);
  await f.loaded;
  console.log('loaded, drawing')
  f.draw(canvas.getContext('2d'));
});
</script>
