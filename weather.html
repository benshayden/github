<canvas id=canvas>
<script>
const MS_PER_HOUR = 1000 * 60 * 60;
const MS_PER_DAY = MS_PER_HOUR * 24;

function convertTemp(k, metric = true) {
  const c = k - 273.15;
  return metric ? c : (c * (9 / 5) + 32);
}

function mean(s) {
  let sum = 0;
  for (const e of s) sum += e;
  return sum / s.length;
}

navigator.geolocation.getCurrentPosition(async (pos) => {
  const lat = parseInt(pos.coords.latitude * 10) / 10;
  const lon = parseInt(pos.coords.longitude * 10) / 10;
  const cacheKey = `${lat} ${lon}`;
  const cached = JSON.parse(localStorage.getItem(cacheKey) || 'null');
  const metric = localStorage.getItem('metric') !== null;
  const now = new Date();
  let result = {date: now, hours: {}, days: [], minima: {}, maxima: {}, aqi: 0};
  if (cached && (MS_PER_HOUR > (cached && (now - new Date(cached.date))))) {
    result = cached;
  } else {
    const [openweathermap, openuv, purpleair] = await Promise.all([
      fetch(`https://api.openweathermap.org/data/2.5/onecall?lat=${lat}&lon=${lon}&appid=4f7a34d2b44e009df9246dbca025d0b5`),
      fetch(`https://api.openuv.io/api/v1/forecast?lat=${lat}&lng=${lon}`, {
        headers: {'x-access-token': '0e881fcec14d82a8eb011877e61bfc21'},
      }),
      fetch(`https://www.purpleair.com/data.json?fields=&nwlat=${lat+0.036}&selat=${lat-0.036}&nwlng=${lon+0.07}&selng=${lon-0.07}`),
    ].map(p => p.then(r => r.json())));
    console.log({openweathermap, openuv, purpleair});

    for (let h = now.getHours(); h < 24; ++h) {
      result.hours[h] = {};
    }
    for (let d = 0; d < 5; ++d) {
      result.days[d] = {};
    }

    for (const datum of openweathermap.hourly) {
      const date = new Date(datum.dt * 1000);
      if (date.getDate() != now.getDate()) continue;
      const target = result.hours[date.getHours()];
      if (!target) continue;
      Object.assign(target, {
        temp: datum.temp,
        feels: datum.feels_like,
        clouds: datum.clouds,
        humidity: datum.humidity,
      });
      for (const k of Object.keys(target)) {
        result.minima[k] = Math.min(result.minima[k] || 1000000, target[k]);
        result.maxima[k] = Math.max(result.maxima[k] || -1000000, target[k]);
      }
    }
    
    for (const datum of openweathermap.daily) {
      const date = new Date(datum.dt * 1000);
      const target = result.days[parseInt((date - now) / MS_PER_DAY)];
      if (!target) continue;
      Object.assign(target, {
        temp: [datum.temp.min, datum.temp.max],
        clouds: datum.clouds,
        humidity: datum.humidity,
      });
      for (const k of ['clouds', 'humidity']) {
        result.minima[k] = Math.min(result.minima[k] || 1000000, target[k]);
        result.maxima[k] = Math.max(result.maxima[k] || -1000000, target[k]);
      }
      result.minima.temp = Math.min(result.minima.temp, target.temp[0]);
      result.maxima.temp = Math.max(result.maxima.temp, target.temp[1]);
    }

    for (const datum of openuv.result) {
      const date = new Date(datum.uv_time);
      if (date.getDate() != now.getDate()) continue;
      if (!result.hours[date.getHours()]) continue;
      // TODO adjust for clouds
      result.hours[date.getHours()].uv = datum.uv;
    }

    result.aqi = mean(purpleair.data.map(row => {
      const datum = {};
      for (let i = 0; i < purpleair.fields.length; ++i) {
        datum[purpleair.fields[i]] = row[i];
      }
      return datum;
    }).filter(datum => datum.Lat !== null && datum.Lon !== null).map(s => {
      console.log(s);
      return 0;
    }));

    localStorage.setItem(cacheKey, JSON.stringify(result));
  }
  console.log(result);
  const ctx = canvas.getContext('2d');

  for (const k of ['temp', 'feels']) {
    result.maxima[k] = convertTemp(result.maxima[k], metric);
    result.minima[k] = convertTemp(result.minima[k], metric);
    for (const h of Object.values(result.hours)) {
      h[k] = convertTemp(h[k], metric);
    }
  }
  for (const d of result.days) {
    d.temp = [convertTemp(d.temp[0], metric), convertTemp(d.temp[1], metric)];
  }
  
  console.log(result);
  
  // TODO draw axes
  
  for (let h = now.getHours(); h < 20; ++h) {
    const datum = result.hours[h];
    console.log({h, datum});
    ctx.fillText(h, 0, 20 * (h - now.getHours()));
    // TODO draw tick
  }
  for (let d = 0; d < 5; ++d) {
    const datum = result.days[d];
    console.log({d, datum});
    ctx.fillText(d, 0, 20 * (d + 20 - now.getHours()));
    // TODO draw tick
  }
});
</script>
