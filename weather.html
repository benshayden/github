<canvas id=canvas>
<script>
const MS_PER_HOUR = 1000 * 60 * 60;
function convertTemp(k, metric = true) {
  const c = k - 273.15;
  return metric ? c : (c * (9 / 5) + 32);
}
navigator.geolocation.getCurrentPosition(async (pos) => {
  const lat = parseInt(pos.coords.latitude * 10) / 10;
  const lon = parseInt(pos.coords.longitude * 10) / 10;
  const cacheKey = `${lat} ${lon}`;
  const cached = JSON.parse(localStorage.getItem(cacheKey) || 'null');
  const metric = localStorage.getItem('metric') !== null;
  const now = new Date();
  let result = {date: now, hours: [], days: [], minima: {}, maxima: {}};
  if (cached && (MS_PER_HOUR > (cached && (now - new Date(cached.date))))) {
    result = cached.result;
  } else {
    const [openweathermap, openuv, purpleair] = await Promise.all([
      fetch(`https://api.openweathermap.org/data/2.5/onecall?lat=${lat}&lon=${lon}&appid=4f7a34d2b44e009df9246dbca025d0b5`),
      fetch(`https://api.openuv.io/api/v1/forecast?lat=${lat}&lng=${lon}`, {
        headers: {'x-access-token': '0e881fcec14d82a8eb011877e61bfc21'},
      }),
      // TODO search https://www.purpleair.com/json.data?fields= for lat,lon
      fetch('https://www.purpleair.com/json?show=37521|40071'),
    ].map(p => p.then(r => r.json())));
    console.log({openweathermap, openuv, purpleair});

    for (let h = now.getHours(); h < 24; ++h) {
      result.hours[h] = {};
    }
    for (let d = 0; d < 5; ++d) {
      result.days[d] = {};
    }

    // TODO copy data to result

    for (const datum of openuv) {
      // TODO adjust for clouds
      if (!result.hours[datum.t.getHours()]) continue;
      result.hours[datum.t.getHours()].uv = datum.uv;
      if (datum.t.getHours() > 20) break;
    }

    localStorage.setItem(cacheKey, JSON.stringify(result));
  }
  console.log(result);
  const ctx = canvas.getContext('2d');

  for (const k of ['temp', 'feels_like']) {
    result.maxima[k] = convertTemp(result.maxima[k], metric);
    result.minima[k] = convertTemp(result.minima[k], metric);
    for (const h of result.hours) {
      h[k] = convertTemp(h[k], metric);
    }
    for (const d of result.daily) {
      for (const x of Object.keys(d[k])) {
        d[k][x] = convertTemp(d[k][x], metric);
      }
    }
  }

  result.maxima = {};
  result.minima = {};
  result.hours = {};
  for (const h of result.hours) {
    h.date = new Date(h.dt * 1000);
    result.hours[h.date.getHours()] = h;
    for (const k of SCALAR_NAMES) {
      result.maxima[k] = Math.max(result.maxima[k] || 0, h[k]);
      result.minima[k] = Math.min(result.minima[k] || 1000000, h[k]);
    }
    if (h.date.getHours() > 20) break;
  }
  
  // TODO draw axes
  
  for (let h = now.getHours(); h < 20; ++h) {
    const datum = result.hours[h];
    console.log({h, datum});
    ctx.fillText(h, 0, 20 * (h - now.getHours()));
    // TODO draw tick
  }
  for (let d = 0; d < 5; ++d) {
    const datum = result.days[d];
    console.log({d, datum});
    ctx.fillText(d, 0, 20 * (d + 20 - now.getHours()));
    // TODO draw tick
  }
});
</script>
