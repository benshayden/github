<!DOCTYPE html>
<meta name="theme-color" content="black">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1">

<flex id=intro style="justify-content: center; height: 100%;">
  <flex col style="justify-content: center; height: 100%;">
    <div>What would you like to read?</div>
    <select id=library>
      <option value="">Open book from library</option>
      <option value="https://dl.dropboxusercontent.com/s/dfhl7gvtidx7u22/arithmancer.txt">The Arithmancer by White Squirrel</option>
    </select>
    <input type=file id=file accept=".txt">
    <button id=clipboard style="width: 100%; font-size: inherit;">
      Text or URL from clipboard
    </button>
  </flex>
</flex>

<flex col id=settings style="display: none; height: 50%; width: 100%; justify-content: center;">
  <div id=progress_container style="position: relative; width: 100%;">
    <div id=progress_inner style="position: absolute; background-color: #88888880; width: 50%; height: 100%; z-index: -100;">
    </div>
    <center id=progress_label>
      <span id=progress_percent>0</span>%: Sentence <span id=progress_sentence></span> of <span id=total_sentences></span>
    </center>
  </div>
  <center id=time_output style="margin: 8px;"></center>
  <div id=current_sentence style="border: 1px solid white;"></div>
  <center style="margin: 8px;">Words per minute: <span id=wpm_output></span></center>
  <input type=range id=wpm min=100 max=1000 step=10 style="width: 100%;" style="margin: 8px;">
  <flex id=skips style="flex-wrap: wrap;">
    <button id=back_start onclick="setProgressSentence(0)">|&lt;</button>
    <button id=back1000 onclick="setProgressSentence(getProgressSentence() - 1000)">&lt;&lt;&lt;&lt;</button>
    <button id=back100 onclick="setProgressSentence(getProgressSentence() - 100)">&lt;&lt;&lt;</button>
    <button id=back10 onclick="setProgressSentence(getProgressSentence() - 10)">&lt;&lt;</button>
    <button id=back onclick="setProgressSentence(getProgressSentence() - 1)">&lt;</button>
    <button id=forward onclick="setProgressSentence(getProgressSentence() + 1)">&gt;</button>
    <button id=forward10 onclick="setProgressSentence(getProgressSentence() + 10)">&gt;&gt;</button>
    <button id=forward100 onclick="setProgressSentence(getProgressSentence() + 100)">&gt;&gt;&gt;</button>
    <button id=forward1000 onclick="setProgressSentence(getProgressSentence() + 1000)">&gt;&gt;&gt;&gt;</button>
    <button id=forward_end onclick="setProgressSentence(SENTENCES.length - 1)">&gt;|</button>
  </flex>
</flex>

<flex id=word style="display: none; font-size: 30px; align-items: center; width: 100%; height: 50%;">
  <span id=prereticle style="width: 20%; text-align: right;">
  </span><span id=reticle style="color: red;">
  </span><span id=postreticle>
  </span>
</flex>
<button id=read style="display: none; position: absolute; width: 100%; height: 50%; bottom: 0;">
  Press and hold to read.
  <br>Release to pause.
</button>

<style>
html {
  height: 100%;
}
body {
  height: 100%;
  background-color: black;
  color: white;
  margin: 0;
}
flex {
  display: flex;
}
flex[col] {
  flex-direction: column;
}
button {
  border-radius: 24px;
  border: none;
  background-color: white;
  color: black;
  font-family: serif;
  font-size: inherit;
  height: 2em;
  outline: none;
  user-select: none;
}
#intro * {
  margin: 4px;
  justify-content: center;
  width: 100%;
}
#skips * {
  flex-grow: 1;
  margin: 4px;
  min-width: 60px;
  white-space: nowrap;
}
</style>

<script>
// TODO lighthouse app

const URL_REGEX = /^(blob|https?|ftp):/;
const CLIPBOARD_HASH = '!clipboard';
const BLINK_MS = 600;
let SENTENCES = [];

const getHash = () => location.hash.substr(1);
const timeout = ms => new Promise(resolve => setTimeout(resolve, ms));

function fullscreen() {
  const D = document.documentElement;
  if (D.requestFullscreen) return D.requestFullscreen();
  if (D.webkitRequestFullscreen) return D.webkitRequestFullscreen();
  if (D.mozRequestFullScreen) return D.mozRequestFullScreen();
}

function parse(txt) {
  SENTENCES = [];
  for (let s of txt.match(/[^\.!\?]+[\.!\?"”']*/g)) {
    s = s.match(/[^ \n]+ */g);
    if (!s) continue;
    SENTENCES.push(s.map(w => w.trim()));
  }
  total_sentences.textContent = SENTENCES.length;
  if (SENTENCES.length === 0) return;

  back1000.style.display = (SENTENCES.length < 2000) ? 'none' : 'block';
  forward1000.style.display = (SENTENCES.length < 2000) ? 'none' : 'block';
  back100.style.display = (SENTENCES.length < 200) ? 'none' : 'block';
  forward100.style.display = (SENTENCES.length < 200) ? 'none' : 'block';
  back10.style.display = (SENTENCES.length < 20) ? 'none' : 'block';
  forward10.style.display = (SENTENCES.length < 20) ? 'none' : 'block';

  intro.style.display = 'none';
  settings.style.display = 'flex';
  read.style.display = 'block';
  let s = getProgressSentence();
  if (s >= SENTENCES.length) s = 0;
  setProgressSentence(s);
  setTimeOutput();
}

function parseURL(url, filename) {
  fetch(url).then(r=>r.text()).then(txt => {
    if (filename) {
      // TODO store txt in indexeddb
    }
    parse(txt);
  });
}

// TODO scan indexeddb and add options to library

function setTimeOutput() {
  let words = 0;
  for (let s = getProgressSentence(); s < SENTENCES.length; ++s) {
    words += SENTENCES[s].length - 1;
  }
  let mins = words / parseInt(wpm.value);
  mins += BLINK_MS * (SENTENCES.length - getProgressSentence()) / 6e4;
  time_output.textContent = '';
  if (mins > 60) time_output.textContent += Math.floor(mins / 60) + ' hours, ';
  time_output.textContent += Math.round(mins % 60) + ' minutes remaining';
}

function reticleIndex(w) {
  const m = w.match(/\w+/);
  if (!m) return 0;
  if (m[0].length === 1) return m.index;
  if (m[0].length < 6) return 1 + m.index;
  return 2 + m.index;
}

async function start() {
  if (word.style.display === 'flex') return;
  fullscreen();
  word.style.display = 'flex';
  read.style.backgroundColor = 'black';
  settings.style.display = 'none';
  const ms = 6e4 / parseInt(wpm.value);
  let starting = true;
  let sentenceIndex = getProgressSentence();
  let wordIndex = 0;
  while (word.style.display === 'flex') { // noprotect
    const w = SENTENCES[sentenceIndex][wordIndex];
    const i = reticleIndex(w);
    prereticle.textContent = w.substr(0, i);
    reticle.textContent = w[i];
    postreticle.textContent = w.substr(i + 1);
    await timeout(starting ? BLINK_MS : ms);
    starting = false;
    ++wordIndex;
    if (wordIndex >= SENTENCES[sentenceIndex].length) {
      if (SENTENCES[sentenceIndex].length > 3) {
        await timeout(BLINK_MS - ms);
      }
      wordIndex = 0;
      sentenceIndex = (sentenceIndex + 1) % SENTENCES.length;
      setProgressSentence(sentenceIndex);
    }
  }
}

function stop() {
  word.style.display = 'none';
  read.style.backgroundColor = 'white';
  settings.style.display = 'flex';
}

function getProgressSentence() {
  return parseInt(localStorage.getItem('progress_sentence_' + getHash())) || 0;
}
function setProgressSentence(s) {
  s %= SENTENCES.length;
  while (s < 0) s += SENTENCES.length;
  progress_sentence.textContent = s;
  progress_percent.textContent = parseInt(100 * s / SENTENCES.length);
  progress_inner.style.width = (100 * s / SENTENCES.length) + '%';
  current_sentence.textContent = SENTENCES[s].join(' ');
  localStorage.setItem('progress_sentence_' + getHash(), s);
  setTimeOutput();
}

wpm.addEventListener('input', () => {
  const wpmv = parseInt(wpm.value);
  localStorage.setItem('wpm', wpmv);
  wpm_output.textContent = wpmv;
  setTimeOutput();
});

clipboard.addEventListener('click', async() => {
  fullscreen();
  let txt;
  try {
    txt = await navigator.clipboard.readText();
  } catch (e) {
    console.log('error reading clipboard', e);
    location.hash = '';
  }
  if (txt.length < 1e4 && txt.match(URL_REGEX)) {
    location.hash = url.value;
  } else {
    intro.style.display = 'none';
    location.hash = CLIPBOARD_HASH;
    setProgressSentence(0);
    parse(txt);
  }
});

file.addEventListener('change', () => {
  fullscreen();
  location.hash = file.value;
  parseURL(URL.createObjectURL(file.files[0]), file.value);
});

library.addEventListener('change', () => {
  fullscreen();
  location.hash = library.value;
});

read.addEventListener('mousedown', start);
read.addEventListener('mouseup', stop);
read.addEventListener('touchstart', start);
read.addEventListener('touchend', stop);
read.addEventListener('contextmenu', e => e.preventDefault());

wpm.value = parseInt(localStorage.getItem('wpm')) || 400;
wpm_output.textContent = wpm.value;

window.onhashchange = async() => {
  if (!getHash()) {
    intro.style.display = 'flex';
    settings.style.display = 'none';
    read.style.display = 'none';
    return;
  }

  if (getHash() === CLIPBOARD_HASH) {
    if (intro.style.display === 'none') return;
    try {
      const txt = await navigator.clipboard.readText();
    } catch (e) {
      console.log('error reading clipboard', e);
      location.hash = '';
      return;
    }
    setProgressSentence(0);
    parse(txt);
    return;
  }

  if (getHash().match(URL_REGEX)) {
    parseURL(getHash());
    return;
  }

  // TODO read file from indexeddb
  location.hash = '';
};
window.onhashchange();
</script>
