<!doctype html>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>few words</title>
<style>
  table {
    border-collapse: collapse;
    margin: auto;
  }
  td {
    padding: 2px 8px;
    text-align: center;
  }
  tx {
    font-style: italic;
  }
</style>

<center>
<tx>word of few</tx>
<br>sound-thought-of-number-big-not
<br>few words
</center>

<p>Oligosynthesis works up to a point. How far can that point be pushed? When are concrete roots better or worse than abstract roots?

<p>Can a strict CV syllable structure with a minimal phonemic inventory account for enough roots?  

<br><button id="authorize_button">Authorize Google Sheets API</button>

<table id=syllables></table>

<h3><center>Compare toki pona vocabulary</center></h3>
<div style="max-height: 19.5em; overflow: auto; margin: auto;">
  <table id=tokipona></table>
</div>

<h3><center>Compare aUI vocabulary</center></h3>
<div style="max-height: 19.5em; overflow: auto; margin: auto;">
  <table id=aui></table>
</div>

<h3><center>Sentence Structure</center></h3>
Simple Intransitive: subject <tx>[predicate]</tx> verb
<ul>
  <li><tx></tx>
    <br>
  <li><tx></tx>
    <br>
</ul>

Simple Transitive: subject <tx>[predicate]</tx> verb <tx>[object]</tx> object
<ul>
  <li><tx></tx>
    <br>
  <li><tx></tx>
    <br>
</ul>

Imperative: <tx>[predicate]</tx> verb
<ul>
  <li><tx></tx>
    <br>
  <li><tx></tx>
    <br>
</ul>

<h3><center>Head-Initial</center></h3>
Nouns before adjectives.
<ul>
  <li><tx></tx>
    <br>
  <li><tx></tx>
    <br>
</ul>
Verbs before adverbs.
<ul>
  <li><tx></tx>
    <br>
  <li><tx></tx>
    <br>
</ul>

<h3><center>Parts of Speech</center></h3>
Most words can be nouns, adjectives, verbs, and adverbs. Use context and your imagination.

<ul>
  <li><tx>person [predicate] want [object] food [context] [predicate] eat [object] food.</tx>
    <br>When hungry, eat.
  <li><tx>person [predicate] want [object] water [context] [predicate] eat [object] water.</tx>
    <br>When thirsty, drink.
</ul>

<h3><center>Pronouns</center></h3>
Instead of having special words for I/me/myself/my/mine, say <tx>person</tx> then your name or some abbreviation. Unlike toki pona, no exception to using <tx>[predicate]</tx> for pronouns.

<ul>
  <li><tx></tx>
    <br>
  <li><tx></tx>
    <br>
</ul>

<h3><center>Questions</center></h3>
Yes/no questions as in toki pona: subject [predicate] verb [not] verb. Yes/no answers similarly: verb or [not].
To ask a who/what/when/where/why question, use <tx>unknown</tx> as an adjective without changing the sentence order.

<ul>
  <li><tx></tx>
    <br>
  <li><tx></tx>
    <br>
</ul>

<h3><center>Prepositions</center></h3>
<table>
  <tr>
    <td></td>
    <td><tx>of</tx></td>
  </tr>
  <tr>
    <td></td>
    <td><tx>to</tx></td>
  </tr>
  <tr>
    <td></td>
    <td><tx>at</tx></td>
  </tr>
  <tr>
    <td></td>
    <td><tx>because</tx></td>
  </tr>
</table>

<h3></center>Foreign Words</center></h3>
For foreign words, do the best you can, and trust that others will, too. Don't correct pronunciation or spelling unless requested.

<ul>
  <li><tx></tx>
    <br>
  <li><tx></tx>
    <br>
</ul>

<h3><center>Proper Names</center></h3>
Proper names work like adjectives.

<ul>
  <li><tx></tx>
    <br>
  <li><tx></tx>
    <br>
</ul>

<h3><center>Numbers</center></h3>
There is a complete number system:
<table id=nums></table>

<h3><center>If/When</center></h3>
<tx>[context]</tx> works like "if" or "when".
<ul>
  <li><tx></tx>
    <br>
  <li><tx></tx>
    <br>
</ul>

<h3><center>Transliterate</center></h3>
<textarea id=en></textarea>
<textarea id=fw></textarea>

<h3><center>Vocabulary</center></h3>
<div style="max-height: 19.5em; overflow: auto; margin: auto;">
  <table id=words></table>
</div>

<script>
const spreadsheetId = '1lOF5iFM41Au5nf6oFgHLb7-kZQbtxVINLYktcYpjVsQ';
const F = {
  fw2en: {},
  en2fw: {},
  
  phrase(s, strict = false) {
    let fw = '';
    for (const en of s.split(' ')) {
      if (strict && !F.en2fw[en]) throw new Error(en);
      fw += ' ' + (F.en2fw[en] || en);
    }
    return fw;
  },

  transliterate() {
    for (const elem of document.querySelectorAll('tx')) {
      if (!elem.en) {
        elem.en = elem.innerText;
      }
      elem.innerText = F.phrase(elem.en);
    }
  },

  async load() {
    const response = await window.gapi.client.sheets.spreadsheets.get({
      spreadsheetId,
      includeGridData: true,
    });
    console.log(response);
    for (const sheet of response.result.sheets) {
      if (sheet.properties.title === 'syllables') {
    	  const table = document.getElementById('syllables');
        const strings = [];
        for (const row of sheet.data[0].rowData) {
          strings.push([]);
          const tr = document.createElement('tr');
          table.appendChild(tr);
          for (let coli = 0; coli < 6; ++coli) {
            const cell = row.values[coli] || {};
            const td = document.createElement('td');
            tr.appendChild(td);
            td.innerText = cell.formattedValue || '';
            strings[strings.length - 1].push(cell.formattedValue);
          }
        }
        for (let rowi = 1; rowi < strings.length; ++rowi) {
          for (let coli = 1; coli < strings[rowi].length; ++coli) {
            const en = strings[rowi][coli];
            if (!en) continue;
            const fw = strings[rowi][0] + strings[0][coli];
            F.fw2en[fw] = en;
            F.en2fw[en] = fw;
          }
        }
      } else if (sheet.properties.title === 'words') {
    	  const table = document.getElementById('words');
        const queue = [];
        for (const row of sheet.data[0].rowData) {
          const tr = document.createElement('tr');
          table.appendChild(tr);
          for (let coli = 0; coli < 2; ++coli) {
            const cell = row.values[coli] || {};
            const td = document.createElement('td');
            tr.appendChild(td);
            td.innerText = cell.formattedValue || '';
          }
          queue.push({en: row.values[0].formattedValue, elements: row.values[1].formattedValue});
          const td = document.createElement('td');
          tr.appendChild(td);
          const tx = document.createElement('tx');
          td.appendChild(tx);
          tx.innerText = row.values[1].formattedValue;
        }
        let prevLength = queue.length + 1;
        while (queue.length !== prevLength) {
          for (let i = 0; i < queue.length; ++i) {
            const {en, elements} = queue[i];
            try {
              const fw = F.phrase(elements, true);
              console.log(en, fw, elements);
              queue.splice(i, 1);
              --i;
              F.en2fw[en] = fw;
              F.fw2en[fw] = en;
            } catch (e) {
              console.log(en, elements, e);
            }
          }
          prevLength = queue.length;
        }
        if (queue.length) {
          console.log('unable to translate', queue);
        }
      } else if (sheet.properties.title === 'toki pona') {
    	  const table = document.getElementById('tokipona');
        for (const row of sheet.data[0].rowData) {
          const tr = document.createElement('tr');
          table.appendChild(tr);
          for (let coli = 0; coli < 2; ++coli) {
            const cell = row.values[coli] || {};
            const td = document.createElement('td');
            tr.appendChild(td);
            td.innerText = cell.formattedValue || '';
          }
          const td = document.createElement('td');
          tr.appendChild(td);
          const tx = document.createElement('tx');
          td.appendChild(tx);
          tx.innerText = row.values[1].formattedValue;
        }
      } else if (sheet.properties.title === 'aUI') {
    	  const table = document.getElementById('aui');
        for (const row of sheet.data[0].rowData) {
          const tr = document.createElement('tr');
          table.appendChild(tr);
          for (let coli = 0; coli < 3; ++coli) {
            const cell = row.values[coli] || {};
            const td = document.createElement('td');
            tr.appendChild(td);
            td.innerText = cell.formattedValue || '';
          }
          const td = document.createElement('td');
          tr.appendChild(td);
          const tx = document.createElement('tx');
          td.appendChild(tx);
          tx.innerText = (row.values[2] || {}).formattedValue || '';
        }
      } else {
        console.log(sheet);
      }
    }
    F.transliterate();
  },
};

addEventListener('load', () => {
  if (window.location.protocol === 'http:') {
    window.location.protocol = 'https:';
    return;
  }
  const script = document.createElement('script');
  script.async = 'async';
  script.defer = 'defer';
  script.src = 'https://apis.google.com/js/api.js';
  script.onreadystatechange = () => {
    if (this.readyState === 'complete') this.onload()
  };
  script.onload = () => {
    this.onload = function(){};
    window.gapi.load('client:auth2', function initClient() {
      window.gapi.client.init({
        clientId: '563656626445-ijrtluv6l4k9v8io4tinnl054onkmvaf.apps.googleusercontent.com',
        apiKey: 'AIzaSyCisRYYgsPjDE0DuiC2Wr8j7K8Mj2aFW-U',
        discoveryDocs: ['https://sheets.googleapis.com/$discovery/rest?version=v4'],
        scope: 'https://www.googleapis.com/auth/spreadsheets',
      }).then(async function () {
        updateSigninStatus();
        window.gapi.auth2.getAuthInstance().isSignedIn.listen(updateSigninStatus);
        document.getElementById('authorize_button').onclick = function handleAuthClick(event) {
          return window.gapi.auth2.getAuthInstance().signIn();
        };
      }, function(error) {
        document.body.innerText = JSON.stringify(error);
      });
    });
  };
  document.head.appendChild(script);
});

function updateSigninStatus() {
  if (window.gapi.auth2.getAuthInstance().isSignedIn.get()) {
    document.getElementById('authorize_button').style.display = 'none';
    F.load();
  } else {
    document.getElementById('authorize_button').style.display = 'block';
  }
}
</script>
