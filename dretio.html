data:text/html,<!doctype html>
<style>
html {
  font-family: monospace;
  background: black;
  color: white;
}
cursor {
  background: white;
  color: black;
}
</style>
Forget modifier keys, the mouse, arrows, symbols, and function keys.
<br>This editor maps the 26 letter keys, spacebar, and maybe a few other keys
<br>to every command: inserting lowercase/uppercase/numbers/symbols, cursor movement,
<br>backspace, delete, spacebar, etc.
<br>More common functions, such as inserting a letter 'e' require fewer strokes than
<br>less common functions, such as inserting a tilde.
<br>This is a compression problem.
<br>But instead of encoding commands as bit-strings,
<br>they are encoded as strings of letters and maybe a few other keys.
<br>If keys were all equally easy to type, then the compression could use a standard
<br>base-30-something Huffman code.
<br>But some keys are preferred more than others.
<br>'j' is easier to type than 'z', so commands are more likely to use 'j' than 'z'.
<cursor>&nbsp;</cursor>
<script>
var i = 0;
while (i < document.body.childNodes.length) {
  var n = document.body.childNodes[i];
  if (n.nodeName === '#text') {
    var text = n.textContent;
    for (var j = 0; j < text.length; ++j) {
      document.body.insertBefore(document.createTextNode(text[j]), n);
    }
    document.body.removeChild(n);
    i += text.length;
  } else {
    ++i;
  }
}

var cursor = document.querySelector('cursor');
var buffer = '';

addEventListener('keypress', handle);
function handle(event) {
  event = event.keyCode;
  if ((event < 97) || (event > 122)) return;
  event = String.fromCharCode(event);
  buffer += event;
  if (commands[buffer]) {
    commands[buffer]();
    buffer = '';
  } else if (buffer.length > maxcmdlen) {
    buffer = '';
  }
}

var commands = {};
var maxcmdlen = 1;

function randCmd(n) {
  n = n || 2;
  var cmd = '';
  while (!cmd || commands[cmd]) {
    cmd = '';
    for (var i = 0; i < n; ++i) {
      cmd += String.fromCharCode(97 + Math.floor(Math.random() * 26));
    }
  }
  if (n > maxcmdlen) {
    maxcmdlen = n;
  }
  return cmd;
}

function def(msg, cb) {
  var cmd = randCmd();
  console.debug(cmd, msg);
  commands[cmd] = cb;
}

function inserter(char) {
  def(char, function() {
    document.body.insertBefore(document.createTextNode(char), cursor);
  });
}

def('back', function() {
  document.body.removeChild(cursor.previousSibling);
});

for (var i = 33; i < 126; ++i) {
  (function(i) {
    inserter(String.fromCharCode(i));
  })(i);
}
inserter(String.fromCharCode(160));

def('newline', function() {
  document.body.insertBefore(document.createElement('br'), cursor);
});

def('left', function() {
  if (!cursor.previousSibling) return;
  var newcursor = document.createElement('cursor');
  var text = cursor.previousSibling;
  /* TODO text is br? */
  document.body.removeChild(text);
  newcursor.appendChild(text);
  document.body.insertBefore(newcursor, cursor);
  text = cursor.childNodes[0];
  cursor.removeChild(text);
  document.body.insertBefore(text, cursor);
  document.body.removeChild(cursor);
  cursor = newcursor;
});

def('right', function() {
  if (!cursor.nextSibling) return;
  var newcursor = document.createElement('cursor');
  var text = cursor.nextSibling;
  /* TODO text is br? */
  document.body.removeChild(text);
  newcursor.appendChild(text);
  text = cursor.childNodes[0];
  cursor.removeChild(text);
  document.body.insertBefore(text, cursor);
  document.body.insertBefore(newcursor, cursor);
  document.body.removeChild(cursor);
  cursor = newcursor;
});

function prevBr() {
  var br = cursor.previousSibling;
  var col = 0;
  while (br && br.nodeName !== 'BR') {
    br = br.previousSibling;
    ++col;
  }
  return {br: br, col: col};
}

function line() {
  var elem = cursor.previousSibling;
  var n = 0;
  while (elem) {
    if (elem.nodeName === 'BR') {
      ++n;
    }
    elem = elem.previousSibling;
  }
  return n;
}

def('up', function() {
  var br = prevBr();
  if (!br.br) return;
  /* TODO */
});

def('down', function() {
  var br = cursor.nextSibling;
  while (br && br.nodeName !== 'BR') {
    br = br.nextSibling;
  }
  if (!br) return;
  /* TODO */
});

function Huffman(hist) {
  var q = [];
  for (var k in hist) {
    q.push({sym: k, w: hist[k]});
  }
}
</script>
