data:text/html,<!doctype html>
<style>
html {
  font-family: monospace;
  background: black;
  color: white;
}
cursor {
  background: white;
  color: black;
}
</style>
Forget modifier keys, the mouse, arrows, symbols, and function keys.
<br>This editor maps the 26 letter keys, spacebar, and maybe a few other keys
<br>to every command: inserting lowercase/uppercase/numbers/symbols, cursor movement,
<br>backspace, delete, spacebar, etc.
<br>More common functions, such as inserting a letter 'e' require fewer strokes than
<br>less common functions, such as inserting a tilde.
<br>This is a compression problem.
<br>But instead of encoding commands as bit-strings,
<br>they are encoded as strings of letters and maybe a few other keys.
<br>If keys were all equally easy to type, then the compression could use a standard
<br>base-30-something Huffman code.
<br>But some keys are preferred more than others.
<br>'j' is easier to type than 'z', so commands are more likely to use 'j' than 'z'.
<cursor>&nbsp;</cursor>
<script>
var i = 0;
while (i < document.body.childNodes.length) {
  var n = document.body.childNodes[i];
  if (n.nodeName === '#text') {
    var text = n.textContent;
    for (var j = 0; j < text.length; ++j) {
      document.body.insertBefore(document.createTextNode(text[j]), n);
    }
    document.body.removeChild(n);
    i += text.length;
  } else {
    ++i;
  }
}

var cursor = document.querySelector('cursor');
var buffer = '';

addEventListener('keypress', handle);
function handle(event) {
  event = event.keyCode;
  if ((event < 97) || (event > 122)) return;
  event = String.fromCharCode(event);
  buffer += event;
  if (commands[buffer]) {
    commands[buffer]();
    buffer = '';
  } else if (buffer.length > maxcmdlen) {
    buffer = '';
  }
}

var commands = {};
var maxcmdlen = 1;

function randCmd(n) {
  n = n || 2;
  var cmd = '';
  while (!cmd || commands[cmd]) {
    cmd = '';
    for (var i = 0; i < n; ++i) {
      cmd += String.fromCharCode(97 + Math.floor(Math.random() * 26));
    }
  }
  if (n > maxcmdlen) {
    maxcmdlen = n;
  }
  return cmd;
}

function def(msg, cb) {
  var cmd = randCmd();
  console.debug(cmd, msg);
  commands[cmd] = cb;
}

function inserter(char) {
  def(char, function() {
    document.body.insertBefore(document.createTextNode(char), cursor);
  });
}

def('back', function() {
  document.body.removeChild(cursor.previousSibling);
});

for (var i = 33; i < 126; ++i) {
  (function(i) {
    inserter(String.fromCharCode(i));
  })(i);
}
inserter(String.fromCharCode(160));

/* TODO APL, other unicode */

def('newline', function() {
  document.body.insertBefore(document.createElement('br'), cursor);
});

def('left', function() {
  if (!cursor.previousSibling) return;
  var newcursor = document.createElement('cursor');
  var text = cursor.previousSibling;
  /* TODO text is br? */
  document.body.removeChild(text);
  newcursor.appendChild(text);
  document.body.insertBefore(newcursor, cursor);
  text = cursor.childNodes[0];
  cursor.removeChild(text);
  document.body.insertBefore(text, cursor);
  document.body.removeChild(cursor);
  cursor = newcursor;
});

def('right', function() {
  if (!cursor.nextSibling) return;
  var newcursor = document.createElement('cursor');
  var text = cursor.nextSibling;
  /* TODO text is br? */
  document.body.removeChild(text);
  newcursor.appendChild(text);
  text = cursor.childNodes[0];
  cursor.removeChild(text);
  document.body.insertBefore(text, cursor);
  document.body.insertBefore(newcursor, cursor);
  document.body.removeChild(cursor);
  cursor = newcursor;
});

function prevBr() {
  var br = cursor.previousSibling;
  var col = 0;
  while (br && br.nodeName !== 'BR') {
    br = br.previousSibling;
    ++col;
  }
  return {br: br, col: col};
}

function line() {
  var elem = cursor.previousSibling;
  var n = 0;
  while (elem) {
    if (elem.nodeName === 'BR') {
      ++n;
    }
    elem = elem.previousSibling;
  }
  return n;
}

def('up', function() {
  var br = prevBr();
  if (!br.br) return;
  /* TODO */
});

def('down', function() {
  var br = cursor.nextSibling;
  while (br && br.nodeName !== 'BR') {
    br = br.nextSibling;
  }
  if (!br) return;
  /* TODO */
});

function bsearch(a, cb) {
    var minIndex = 0;
    var maxIndex = a.length - 1;
    while (minIndex <= maxIndex) {
        var idx = Math.floor((minIndex + maxIndex) / 2);
        var elem = a[idx];
        var q = cb(elem);
        if (q < 0) {
            minIndex = idx + 1;
        } else if (q > 0) {
            maxIndex = idx - 1;
        } else {
            return idx;
        }
    }
    return -1;
}

function Huffman(cmdhist, codekeyhist) {
  var codekeys = [];
  for (var codekey in codekeyhist) {
    codekeys.push({codekey: codekey, freq: codekeyhist[codekey]});
  }
  codekeys.sort(function(a, b) {
    return a.freq - b.freq;
  });
  var q = [];
  for (var k in cmdhist) {
    q.push({sym: k, freq: cmdhist[k]});
  }
  while ((q.length % (codekeys.length - 1)) !== 1) {
    q.push({freq: 0});
  }
  q.sort(function(a, b) {
    return a.freq - b.freq;
  });
  function makeInternalNode(childCount) {
    var internal = {freq: 0, code: '', children: q.splice(0, childCount)};
    internal.children.forEach(function(child) {
      internal.freq += child.freq;
      child.parent = internal;
    });
    q.splice(bsearch(q, function(other) {
      return other.freq - internal.freq;
    }), 0, internal);
  }
  while (q.length > codekeys.length) {
    makeInternalNode(codekeys.length);
  }
  if (q.length !== codekeys.length) {console.error(q); throw 'Huffman logic error'; }
  var codes = {};
  function assignCode(node, index) {
    node.code = (node.parent ? node.parent.code : '') + codekeys[index].codekey;
    if (node.sym) codes[node.sym] = node.code;
    if (node.children) node.children.forEach(assignCode);
  }
  q.forEach(assignCode);
  return codes;
}

var commands2 = Huffman({commandname: 0.42}, {j: 0.042, f: 0.041});

function commandmapscore(commands2, cmdhist, codekeyhist) {
  var score = 0;
  var commandcount = 0;
  for (var command in commands2) {
    ++commandcount;
    var code = commands2[command];
    for (var keyi = 0; keyi < code.length; ++keyi) {
      score += cmdhist[command] * codekeyhist[code[keyi]];
    }
  }
  return score / commandcount;
}
</script>
